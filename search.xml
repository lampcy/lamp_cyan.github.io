<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>2019todoList</title>
      <link href="/2019/02/21/2019todoList/"/>
      <url>/2019/02/21/2019todoList/</url>
      <content type="html"><![CDATA[<blockquote><p>新年伊始，又到了立下一批flag的时候，记录下来方便自己年底总(打)结(脸)，大目标永远都是一个：今年的自己一定要比去年更优秀哇~</p></blockquote><h3 id="工作-amp-技术"><a href="#工作-amp-技术" class="headerlink" title="工作 &amp; 技术"></a>工作 &amp; 技术</h3><ul><li>完成至少一个完整的业务项目（构思产品 + UI + 开发）；</li><li>每个月完成一篇博客，督促自己学习新知识或者巩固老知识；</li><li>每周需要6小时的零碎时间学习，跳出工作之外，增加广度，建议每天晚上回去与老公一小时餐桌学习；</li><li>工作有所突破，跳出舒适圈，多思考，多为团队贡献，产出至少一项技术类突破点或者完成某个项目来贡献团队；</li><li>学习一门新技术TypeScript;</li><li>每周保证四天每天抽20分钟来看前端前沿新闻或者牛人博客或公众号；</li><li>每月小结</li></ul><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><ul><li>旅游(与老公的蜜月旅游，带父母去北京)</li><li>购买保险</li><li>学会游泳</li><li>开启理财之路（三分之一定期，三分之一投资，三分之一周转）</li><li>买车并自己学会开车（虽有驾照，但是驾龄为0）</li><li>与老公每个月存钱，慢慢靠近低物欲生活</li><li>开始化妆(眼妆)</li></ul><p>研究生毕业之后，工作2年多了，内心经常怀疑自己，读研的那三年收获了什么，会比三年的工作经验更有价值吗，会经常质疑自己能力是不是太菜，技术成长是否太慢了，对比一些格局比较高的人，自己简直就是井底之蛙等等，会经常受这些情绪影响，希望自己19年能尽量实现心态上的进步，克服焦虑，不以物喜，不以己悲，踏实做好自己定下来的计划，不受外界影响。</p>]]></content>
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2018年终总结</title>
      <link href="/2019/02/13/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>/2019/02/13/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<blockquote><p>2018的年终总结本来应该在2018年年末完成，但是年底实在是太忙，装修，拍婚纱照，两场婚礼，新婚走亲戚，过年连休了大半个月，拖到现在才有时间来总结下，以往的年终总结都是发给老大看，考虑到没人会关心你自己的私生活和感受，多半是对工作上的总结，打算从18年开始全面总结下自己的各方面，记录在博客中，说起博客真是惭愧，从学生时代就开始折腾这玩意，当时是在一个w3c什么网站上开启的博客，谁知道几年过去突然就挂了，自己写了啥已经全然不记得了，只好在github上重新整一个，希望自己能坚持下去。</p></blockquote><h3 id="工作-amp-技术"><a href="#工作-amp-技术" class="headerlink" title="工作 &amp; 技术"></a>工作 &amp; 技术</h3><p>以前说到工作，我经常总结自己是业务型选手，干活麻利，干劲十足，天天加班写业务都无所谓，上线一个就超有成就感，这大概是毕业一年内一直存在的新鲜感吧，而在18年依旧是业务非常忙碌的一年，但是开始了更多的思考，反思自己是不是就是写需求的机器，经常陷入焦虑之中，其实我并不觉得焦虑不好，对我自己来说反而是一种动力，所以在18年结合业务目前面临的问题做了比较多的技术改造；</p><h4 id="1-主导技术改造"><a href="#1-主导技术改造" class="headerlink" title="1. 主导技术改造"></a>1. 主导技术改造</h4><p>一次机缘巧合的支援了公司某个业务的改版，一点小需求真是做到吐血，因为公共模板问题，改很多套不同系统的项目，从修改到发布做了很多重复的事情，开发环境和发布系统不统一导致开发和学习成本都比较大，于是牵头做了一次迁移，集中一套开发环境，一套发布系统，前后端完全分离，梳理出一套规范的公共模板。</p><p>做事情本身不难，但是推动大家一起去做件事是最难的，这个角色不同于一个项目的PM。为了让大家更方便的迁移，先自己踩坑走一遍，模板梳理好，出一套最简洁的方案提供给大家，把目前存在的问题和以后的成本开会告知大家，从迁移方案到发布计划到灰度一整套下来，自己还真学到了不少，都快把公司业务发展史翻了个遍，期间和很多开发，后端，运维等都有合作，感觉自己一个Q讲了好几个Q的话。迁移完之后刚好赶上公司做时尚内容的转型，涉及到了多方改版，大家都体会到方便了，特别是对于公共模板维护者来说，再也不用维护多套了。除了业务开发，这个事情让自己还挺有成就感的。</p><h4 id="2-业务的拓展"><a href="#2-业务的拓展" class="headerlink" title="2. 业务的拓展"></a>2. 业务的拓展</h4><p>18年一共换了3次团队，之前大部门主管夸过我说公司发生巨大变化，人员变动很厉害的时候我的状态一直保持很好，并且适应能力很强，也正是因为这样我接触了公司更多的业务方向，之前老大说我对团队内业务关注不够，从而找不到服务团队的点。但我总觉得不真正的实践是不会有深入了解和发现问题的，但是我一直对主动去帮别人写业务需求这件事情有点犹豫，害怕别人会认为我觊觎其他人的业务，老大提出之后，我也把我想法说了，老大只是说先去试试，万一大家不会这样想呢。因此Q3抱着试试的心态，时间充裕的时候有帮团队内其他业务做过迁移，例如下单，购物车，订单，详情等，大家也都非常开心，于他们是帮他们分担了一些工作，从而大家的时间都相对变得宽裕点，于我了解电商链路更多的东西，除开业务了解外，也发现了一些问题，有些业务的模式完全可以用搭建页面的方式来提升开发效率，因为自己负责的业务就是经过改造之后采用模块化搭建的形式，感觉也可以其他业务，解放劳动力，因此就有了后面的可视化搭建的想法，这个只能列到一些不算成功的项目中去😂。</p><h4 id="3-技术深度"><a href="#3-技术深度" class="headerlink" title="3. 技术深度"></a>3. 技术深度</h4><p>7月的时候从微选回到蘑菇街新团队还是有点处于迷茫的状态，一个是之前团队内的小伙们纷纷离职，老团队内就剩我一个人，二个是那段时间比较空闲焦虑，为了摆脱这种状态让自己静心，决定开始看书巩固基础。</p><ul><li><p>一直对node处于了解阶段，从未真正实践过，因为利用这段时间开始写node插件，服务自己平时开发需要用到的功能，效果还可以，可惜的是当时没有好好总结，现在开始有点淡忘了。</p></li><li><p>也从那个时间开始看源码，每天花了一点时间来看vue源码，我只能说第一遍啃完以后发现对日常开发并没有多大帮助，可见我们平时的工作有多么没有技术含量，任何人都可以替换我们。看完以后为了加深理解，准备在博客总结自己所看的东西，于是就有了前面的那一边vue源码解析，拖着还没写完实在汗颜，虽然时间比较慢，但是好歹是个不错的开头，后面会继续花时间看源码总结。</p></li></ul><p>总体来说18年对自己的技术成长不是很满意，没有摄入自己满意的新知识，对老知识也没有太多回顾。</p><h4 id="一些不太成功的项目"><a href="#一些不太成功的项目" class="headerlink" title="一些不太成功的项目"></a>一些不太成功的项目</h4><p>可视化搭建平台工具： 这个可谓是我寄予厚望的，自己负责的店铺业务通过可视化搭建之后开发效率提升的不止一点点，而通过观察公司内很多业务都很适用，特别是后台之类的，于是开始构思如何抽离一个可视化搭建的工具，让大家快速搭建自己的搭建平台，快速生成页面，实现模块复用，schema的生成，模块编辑需要的编辑表单动态生成等都详细的写在方案里，与老大和团队内小伙伴都开了几次会表达自己的想法，最后未能成功，一个原因是大家认为自己的目前开发状态挺好的，copy代码能应付目前的需求量，也就是收益和成本不成正比，我也非常理解，其次我可能没有提供一个非常完美的方案，还是让大家有一定的工作量，很多业务方向的考虑没有想清楚。但是这个产出技术方案的过程于我还是非常有帮助的，是段不错的经历。</p><p>公司内vue组件统一规范，目的是让不同的业务之间能复用模块，让店铺拥有更多的可配置模块，这个也是源于当时运营提的一个需求，希望在店铺中既能展示活动页面所用的营销模块和商家自己装修的店铺模块，但当时现状就是不能满足，简单理解就是营销活动那边的模块和店铺的模块不能通用，于是和另一个小伙伴着手弄这个事情，但是弄完之后，这类的需求就再也没来过😂，但是呢，借此机会规范了公司内组件模块的命名规范，css规范，schema规范，统一了脚手架，所以也不是没有价值的</p><h4 id="获奖"><a href="#获奖" class="headerlink" title="获奖"></a>获奖</h4><p>18年年终大会的时候，意外收获了星火个性奖，旨在表彰这一年来为减少团队开发成本所做的技术改造，可以是很开心了，之前都没有透露，到上台那一刻才通知，着实惊喜了一下。18更换了三个团队，老大们都自己都很不错，非常幸运。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>18年的生活用非常忙碌来形容再合适不过了，列举几个大事记就知道自己根本没有空余时间出去浪</p><ul><li>订婚</li><li>婚纱照</li><li>新房装修</li><li>婚礼</li></ul><h4 id="有了家"><a href="#有了家" class="headerlink" title="有了家"></a>有了家</h4><p>和相恋3年多的男友步入了婚姻的殿堂，我是典型的爱自由的射手座，本身对结婚这件事我是拒绝的，这不是说我不想和我男友结婚，而是我本身排斥结婚这件事，但是看着日渐年迈的父母，我还是妥协了，婚后并没有自己想的那么恐怖，公公婆婆偶尔过来帮忙做一些好吃的，和老公还是和之前一样给对方足够的空间和自由，生活并没有发生多大的变化，自认为是一个超级独立和理性的人，一直觉得自己不需要男朋友，谈的次数也是极少的，但是现在结婚了感觉还是有点奇妙的，现在的期望就是一直保持现状就好，不想被打破。</p><p>装修我真的是不想吐槽了，没有时间也导致了非常费钱，本来计划30万搞定的，预算超了10万，快40万还没搞完，这点自己非常不满意又没有办法，哈哈。这种事只能说有了一次以后下次应该有经验了吧。</p><h4 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h4><p>18年理财总结：0。因为傻傻的用了快40万现金来装修房子，因此18年基本没有钱开启理财之路，顶多余额宝收获了一点收益，这个事情我只能19年继续努力，好好学习理财。</p><h4 id="家人"><a href="#家人" class="headerlink" title="家人"></a>家人</h4><p>18年老爸因为肾结石住了一次院，有一位多年糖尿病并还不听话的爸，宛若一个定时炸弹一样，我一直都非常关注爸妈的身体，一年叮嘱一次体检，但是最近公司同事家人生病来筹钱的事情告诉了我光有体检没有用，保险意识要加强，19年3月一定要给家人购入保险。</p><h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><p>已经成为过去的就不要介怀，19年要更好呀~</p>]]></content>
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Vue的源码解析</title>
      <link href="/2018/07/16/Vue%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/07/16/Vue%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<blockquote><p>Vue是最典型的MVVM组件化框架，相对于MVC（虽然分层，但是需要手动维护数据和视图的关系），Vue是数据驱动视图，自动更新。今天我们来通过源码解析Vue的完整运行机制。</p></blockquote><img src="/2018/07/16/Vue的源码解析/运行机制.jpg"><ul><li>new Vue():<br>  各种初始化的过程，源码入口有许多init函数，<code>initMixin</code>，<code>stateMixin</code>，<code>eventsMixin</code>，<code>lifecycleMixin</code>等来完成各种初始化工作；</li><li>init:<br>  在<code>new Vue()</code>之后又，通过调用<code>this._inint(options)</code>来初始化生命周期，事件，data，props，computed与watch等，通过<code>Object.defineProperty</code>设置<code>setter</code>与<code>getter</code>来实现响应式和依赖收集。</li><li>$mount：<br>  初始化后挂载组件；</li><li>compile：编译过程，这一步是为了实现将<code>template</code>编译成渲染<code>VNode</code>所需的<code>render function</code>。</li><li>从    render function -&gt; watcher -&gt; patch() -&gt; Virtual DOM Tree  &amp;&amp; render function -&gt; Virtual DOM Tree：Vue的响应式。</li></ul><p>入口文件从<code>src/core/index.js</code>进入<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'./instance/index'</span>   <span class="comment">// vue核心方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; initGlobalAPI &#125; <span class="keyword">from</span> <span class="string">'./global-api/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123; isServerRendering &#125; <span class="keyword">from</span> <span class="string">'core/util/env'</span></span><br><span class="line"><span class="keyword">import</span> &#123; FunctionalRenderContext &#125; <span class="keyword">from</span> <span class="string">'core/vdom/create-functional-component'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化全局变量</span></span><br><span class="line">initGlobalAPI(Vue)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$isServer'</span>, &#123;</span><br><span class="line">  get: isServerRendering</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$ssrContext'</span>, &#123;</span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$vnode &amp;&amp; <span class="keyword">this</span>.$vnode.ssrContext</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// expose FunctionalRenderContext for ssr runtime helper installation</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue, <span class="string">'FunctionalRenderContext'</span>, &#123;</span><br><span class="line">  value: FunctionalRenderContext</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.version = <span class="string">'__VERSION__'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure></p><p>本文主要是理解三个重要部分：响应式原理 &amp;&amp; compile &amp;&amp; 异步更新</p><h4 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h4><p>new一个Vue实例时，会调用<code>init</code>初始化函操作，这部分代码在<code>src/core/instance/init.js</code>中，<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vm生命周期相关变量初始化</span></span><br><span class="line">   initLifecycle(vm)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// vm事件监听初始化</span></span><br><span class="line">   initEvents(vm)</span><br><span class="line">   initRender(vm)</span><br><span class="line">   callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">   initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// vm状态初始化</span></span><br><span class="line">   initState(vm)</span><br><span class="line">   initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">   callHook(vm, <span class="string">'created'</span>)</span><br></pre></td></tr></table></figure></p><p>其中实现响应式原理的基础在于<code>initState(vm)</code>，这里面实现了<code>props</code>，<code>methods</code>，<code>data</code>，<code>computed</code>，<code>watch</code>的初始化操作。前面有说过Vue是通过<code>Object.defineProperty</code>设置<code>setter</code>与<code>getter</code>来实现响应式的。那么具体是怎样实现的呢，主要依赖三个类：<code>Watcher</code>，<code>Dep</code>，<code>Observer</code><br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i--) &#123;</span><br><span class="line"><span class="keyword">const</span> key = keys[i]</span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a data property.`</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">  process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">    <span class="string">`The data property "<span class="subst">$&#123;key&#125;</span>" is already declared as a prop. `</span> +</span><br><span class="line">    <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">    vm</span><br><span class="line">  )</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">  proxy(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// observe data</span></span><br><span class="line">observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br></pre></td></tr></table></figure></p><p> 这里的<code>observe</code>方法是将<code>data</code>变成可观察的，主要是实现了<code>setter</code>与<code>getter</code>方法，让<code>watcher</code>可以观察到数据的变化，那么我们来看看<code>observe</code>的实现：<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; <span class="comment">// number of vms that has this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">const</span> augment = hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">      <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Walk through each property and convert them into</span></span><br><span class="line"><span class="comment">   * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment">   * value type is Object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过使用<code>walk</code>方法把<code>data</code>对象中数据使用<code>defineReactive</code>方法绑定<code>setter/getter</code>，从方法定义的名字来看有可知道作用是定义为可响应式的。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defineReactive方法是实现绑定的核心方法；</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        get: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">                dep.addSub(Dep.target)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (val === newVal) <span class="keyword">return</span>;</span><br><span class="line">           <span class="comment">// 通知订阅者，数值发生改变了；</span></span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为每个data声明一个dep实例对象，随后这个dep就被对应的data给闭包应用了。简单说就是对某个值进行取值和修改时，它的dep实例都可以访问到，不会消失。通过Dep.target来判断是否要收集依赖，这个是全局变量，保存当前的watcher实例，在new Watcher()的时候进行赋值，赋值为当前Watcher实例。Dep是一个订阅者，主要用来存放<code>Watcher</code>观察者对象。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="comment">/* 用来存放Watcher对象的数组 */</span></span><br><span class="line">        <span class="keyword">this</span>.subs = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在subs中添加一个Watcher对象 */</span></span><br><span class="line">    addSub (sub) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通知所有Watcher对象更新视图 */</span></span><br><span class="line">    notify () &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> &#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>未完待续。。。。。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>理解 ES7 的 async/await</title>
      <link href="/2018/07/12/%E7%90%86%E8%A7%A3-ES7-%E7%9A%84-async-await/"/>
      <url>/2018/07/12/%E7%90%86%E8%A7%A3-ES7-%E7%9A%84-async-await/</url>
      <content type="html"><![CDATA[<p>进入正题之前，我们先看一下经典的面试题目：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, j);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</span><br></pre></td></tr></table></figure><p>如果想要实现每隔一秒输出，输出顺序为0，1，2，3，4，5，该怎么改呢？</p><p>先说一下原始题目的输出结果：先输出5，然后顺次输出0，1，2，3，4，为什么会是这个结果呢 ?<code>for</code>循环里用到了闭包，利用一个匿名函数包裹出了一个块级作用域，每循环一次往匿名函数传入的参数会被拷贝一份，因此在<code>for</code>循环外console.log开始打印的时候i的循环已经结束，值为5，由于匿名函数中的setTimeout是异步的，因此外层console.log会先打印，然后顺次输出之前拷贝的值。另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><p>but，用es6的<code>let</code>, 会提示    <code>i is is not defined</code>哦，至于原因大家可以去看看let 和 var的区别。</p><p>言归正传，想要实现题目的中效果，有以下几种方式：</p><ul><li><p>ES5:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, j);</span><br><span class="line">&#125;, <span class="number">1000</span> * j);</span><br><span class="line">&#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</span><br><span class="line">&#125;, <span class="number">1000</span>*i)</span><br></pre></td></tr></table></figure><p>  既然全局的<code>i</code>已经变成了5，那么利用外层的setTimeout来异步输出，内部的setTimeout按照自己当前值的时间计数执行就好，这样会每隔1s输出一个数字，顺序为：0，1，2，3，4，5</p></li><li><p>ES6 Promise:</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> taskArr = [];</span><br><span class="line"><span class="keyword">const</span> output = <span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</span><br><span class="line">resolve();</span><br><span class="line">&#125;, <span class="number">1000</span>*i)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">taskArr.push(output(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(taskArr).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></code></pre><p>  定义一个<code>taskArr</code>数组存放异步操作的<code>promise</code>实例, 使用<code>Promise.all</code>等待所有的<code>promise</code>实例执行结束后，再继续往下执行。</p></li></ul><ul><li>ES7 async &amp;&amp; await<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">time</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(resolve, time);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> asyncPrint = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">asyncPrint();</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>通过上面的例子是不是大概清楚了async/await的用法了呢？</p><h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><h5 id="async-返回值"><a href="#async-返回值" class="headerlink" title="async 返回值"></a>async 返回值</h5><p>有人说ES7定义出的<code>aysnc</code>函数终于让JavaScript对于异步操作有了终极解决方案，摆脱了回调地狱回调。简单俩说<code>async</code>用来定义一个异步函数，该函数返回了一个Promise对象，<code>await</code>从语义上理解就是等待的意思，<code>await</code>的承诺是风里雨里都会等待动作完成才会执行下面的操作，我们看下面的例子：<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">resolve(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"><span class="keyword">await</span> fn().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>输出结果：2s后打印1，然后打印2。就证明上面的解释，<code>await</code>会等待fn完全运行完成并且异步回调也执行完毕后才会继续往下执行。</p><h5 id="async-处理异常"><a href="#async-处理异常" class="headerlink" title="async 处理异常"></a>async 处理异常</h5><p>我们先来下普通的回调函数是如何处理异常的：<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'not_exist_file'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error caught: "</span> + e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为：undefined，而且不是catch里面捕获的错误。原因是：当文件不存在的时候，最外层的try catch并未捕获到异常，而是执行了try里面的执行不存在的文件，自然会输出undefined。由于异步调用分为两个阶段，一个是提交请求，一个处理结果，这两个阶段都有事件循环调用，属于不同的事件循环，彼此没有关联，callback属于处理结果的，而try catch属于外层的异步调用，只能处理当次时间循环中的异常，对callback无能为力，因此无法捕获callback的异常。</p><p>async的异常处理</p><p>不论是同步或者异步的异常，await都不会自动捕获，但是可以自动中函数，如：<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">reject(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"><span class="keyword">await</span> fn();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>最后一行的<code>console.log(2)</code>永远都不会执行</p><p>我们使用<code>try catch</code>来捕获异常，如：<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">reject(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">await</span> fn();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'error'</span>, error);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p><code>console.log(1)</code> 不执行，程序会输出<code>error 出错了</code>。</p><p>关于<code>async await</code>的用法就写这么多，感觉很啰嗦，希望自己很久之后回过头来还看的懂。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
