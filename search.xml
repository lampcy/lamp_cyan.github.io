<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>理解 ES7 的 async/await</title>
      <link href="/2018/07/12/%E7%90%86%E8%A7%A3-ES7-%E7%9A%84-async-await/"/>
      <url>/2018/07/12/%E7%90%86%E8%A7%A3-ES7-%E7%9A%84-async-await/</url>
      <content type="html"><![CDATA[<p>进入正题之前，我们先看一下经典的面试题目：</p><pre><code>for (var i = 0; i &lt; 5; i++) {    (function(j) {        setTimeout(() =&gt; {            console.log(new Date, j);        }, 1000);    })(i)}console.log(new Date, i);</code></pre><p>如果想要实现每隔一秒输出，输出顺序为0，1，2，3，4，5，该怎么改呢？</p><p>先说一下原始题目的输出结果：先输出5，然后顺次输出0，1，2，3，4，为什么会是这个结果呢 ?<code>for</code>循环里用到了闭包，利用一个匿名函数包裹出了一个块级作用域，每循环一次往匿名函数传入的参数会被拷贝一份，因此在<code>for</code>循环外console.log开始打印的时候i的循环已经结束，值为5，由于匿名函数中的setTimeout是异步的，因此外层console.log会先打印，然后顺次输出之前拷贝的值。另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><p>but，用es6的<code>let</code>, 会提示    <code>i is is not defined</code>哦，至于原因大家可以去看看let 和 var的区别。</p><p>言归正传，想要实现题目的中效果，有以下几种方式：</p><ul><li><p>ES5:</p><pre><code>for (var i = 0; i &lt; 5; i++) {    (function(j) {        setTimeout(() =&gt; {            console.log(new Date, j);        }, 1000 * j);    })(i)}setTimeout(() =&gt; {    console.log(new Date, i);}, 1000*i)</code></pre><p>  既然全局的<code>i</code>已经变成了5，那么利用外层的setTimeout来异步输出，内部的setTimeout按照自己当前值的时间计数执行就好，这样会每隔1s输出一个数字，顺序为：0，1，2，3，4，5</p></li><li><p>ES6 Promise:</p><pre><code>const taskArr = [];const output = (i) =&gt; {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            console.log(new Date, i);            resolve();        }, 1000*i)    })}for (var i = 0; i &lt; 5; i++) {    taskArr.push(output(i));}Promise.all(taskArr).then(() =&gt; {    setTimeout(() =&gt; {        console.log(new Date, i);    }, 1000);});</code></pre><p>  定义一个<code>taskArr</code>数组存放异步操作的<code>promise</code>实例, 使用<code>Promise.all</code>等待所有的<code>promise</code>实例执行结束后，再继续往下执行。</p></li></ul><ul><li><p>ES7 async &amp;&amp; await</p><pre><code>const sleep = (time) =&gt; new Promise((resolve) =&gt; {    setTimeout(resolve, time);});const asyncPrint = async () =&gt; {    for(var i = 0; i &lt; 5; i++) {        await sleep(1000);        console.log(new Date, i);    }    await sleep(1000);    console.log(new Date, i);}asyncPrint();</code></pre></li></ul><p>通过上面的例子是不是大概清楚了async/await的用法了呢？</p><h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><h5 id="async-返回值"><a href="#async-返回值" class="headerlink" title="async 返回值"></a>async 返回值</h5><p>有人说ES7定义出的<code>aysnc</code>函数终于让JavaScript对于异步操作有了终极解决方案，摆脱了回调地狱回调。简单俩说<code>async</code>用来定义一个异步函数，该函数返回了一个Promise对象，<code>await</code>从语义上理解就是等待的意思，<code>await</code>的承诺是风里雨里都会等待动作完成才会执行下面的操作，我们看下面的例子：</p><pre><code>export const fn = () =&gt; {    return new Promise((resolve,reject) =&gt; {        setTimeout(() =&gt; {            resolve(1);        }, 2000)    });}(async () =&gt; {    await fn().then((res) =&gt; {        console.log(res);    });    console.log(2)})()</code></pre><p>输出结果：2s后打印1，然后打印2。就证明上面的解释，<code>await</code>会等待fn完全运行完成并且异步回调也执行完毕后才会继续往下执行。</p><h5 id="async-处理异常"><a href="#async-处理异常" class="headerlink" title="async 处理异常"></a>async 处理异常</h5><p>我们先来下普通的回调函数是如何处理异常的：</p><pre><code>var fs = require(&apos;fs&apos;);try{    fs.readFile(&apos;not_exist_file&apos;, &apos;utf8&apos;, function(err, data){        console.log(data);    });}catch(e){    console.log(&quot;error caught: &quot; + e);}</code></pre><p>输出结果为：undefined，而且不是catch里面捕获的错误。原因是：当文件不存在的时候，最外层的try catch并未捕获到异常，而是执行了try里面的执行不存在的文件，自然会输出undefined。由于异步调用分为两个阶段，一个是提交请求，一个处理结果，这两个阶段都有事件循环调用，属于不同的事件循环，彼此没有关联，callback属于处理结果的，而try catch属于外层的异步调用，只能处理当次时间循环中的异常，对callback无能为力，因此无法捕获callback的异常。</p><p>async的异常处理</p><p>不论是同步或者异步的异常，await都不会自动捕获，但是可以自动中函数，如：</p><pre><code>export const fn = () =&gt; {    return new Promise((resolve,reject) =&gt; {        setTimeout(() =&gt; {            reject(&apos;出错了&apos;);        }, 2000)    });}(async () =&gt; {    await fn();    console.log(2);})()</code></pre><p>最后一行的<code>console.log(2)</code>永远都不会执行</p><p>我们使用<code>try catch</code>来捕获异常，如：</p><pre><code>export const fn = () =&gt; {    return new Promise((resolve,reject) =&gt; {        setTimeout(() =&gt; {            reject(&apos;出错了&apos;);        }, 2000)    });}(async () =&gt; {    try{        await fn();        console.log(&apos;1&apos;);    } catch (error) {        console.log(&apos;error&apos;, error);    }})()</code></pre><p><code>console.log(1)</code> 不执行，程序会输出<code>error 出错了</code>。</p><p>关于<code>async await</code>的用法就写这么多，感觉很啰嗦，希望自己很久之后回过头来还看的懂。</p>]]></content>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
